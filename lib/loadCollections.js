// Generated by CoffeeScript 1.11.1
var Collection, collectionsPromise, promises, types,
  hasProp = {}.hasOwnProperty;

promises = require('./promises');

types = require('./types');

Collection = require('./model').Collection;

collectionsPromise = null;

module.exports = function(request, cachedCollections) {
  if (!collectionsPromise || collectionsPromise.getStatus() === 'reject') {
    collectionsPromise = request.get(teamsnap.apiUrl).then(function(xhr) {
      var collections, key, loads, ref, ref1, ref2, ref3, root, rootTypeToRels, value;
      collections = {};
      collections.root = root = Collection.fromData(xhr.data);
      if (cachedCollections && cachedCollections.root.version === root.version) {
        collections = {};
        for (key in cachedCollections) {
          value = cachedCollections[key];
          collections[key] = new Collection(value);
        }
        return collectionsPromise = promises.resolve(collections);
      } else {
        rootTypeToRels = {};
        loads = [];
        ref = collections.root.links;
        for (key in ref) {
          if (!hasProp.call(ref, key)) continue;
          value = ref[key];
          rootTypeToRels[value.href] = key;
        }
        if ((ref1 = collections.root) != null ? (ref2 = ref1.links) != null ? (ref3 = ref2.schemas) != null ? ref3.href : void 0 : void 0 : void 0) {
          loads.push(request.get(collections.root.links.schemas.href).then(function(xhr) {
            return xhr.data.forEach(function(collection) {
              var rel;
              rel = rootTypeToRels[collection.collection.href];
              if (rel && rel !== "root") {
                return collections[rel] = Collection.fromData(collection);
              }
            });
          }));
        } else {
          types.getTypes().forEach(function(type) {
            var rel;
            rel = types.getPluralType(type);
            if (root.links.has(rel)) {
              return loads.push(request.get(root.links.href(rel)).then(function(xhr) {
                return collections[rel] = Collection.fromData(xhr.data);
              }));
            }
          });
        }
        return promises.when.apply(promises, loads).then(function() {
          return collections;
        });
      }
    });
  }
  return collectionsPromise;
};

module.exports.clear = function() {
  return collectionsPromise = null;
};
